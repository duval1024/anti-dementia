# p1_两数之和
## 题目描述
 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 

 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 

 你可以按任意顺序返回答案。 

 

 示例 1： 

 ```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
 ```

 示例 2： 

 ```
输入：nums = [3,2,4], target = 6
输出：[1,2]
 ```

 示例 3： 

 ```
输入：nums = [3,3], target = 6
输出：[0,1]
 ```

 

 提示： 

 ```
 2 <= nums.length <= 103 
 -109 <= nums[i] <= 109 
 -109 <= target <= 109 
 只会存在一个有效答案 
 ```

 
## 题目难度
> ★★★
## 核心知识
哈希表
## 解题思路

暴力法需要O(n^2)复杂度，使用哈希表可以降低一维复杂度：

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer,Integer> numToIndexMap = new HashMap<>(nums.length);
    for (int index = 0; index < nums.length; index++) {
        int targetNum = target - nums[index];
        if (numToIndexMap.containsKey(targetNum)) {
            return new int[]{index, numToIndexMap.get(targetNum)};
        } else {
            numToIndexMap.put(nums[index], index);
        }
    }

    return null;
}
```

```go
func twoSum(nums []int, target int) []int {
    numMap := make(map[int]int, len(nums))
    for index, num := range nums {
        another := target - num 
        if anotherIndex, ok := numMap[another]; ok {
            return []int{index, anotherIndex}
        } else {
            numMap[num] = index
        }
    }

    return nil
}

```
## 其他补充
