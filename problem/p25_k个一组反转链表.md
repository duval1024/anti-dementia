# p25_kä¸ªä¸€ç»„åè½¬é“¾è¡¨
## é¢˜ç›®æè¿°
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ç¿»è½¬åçš„é“¾è¡¨ã€‚ 

 k æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚ 

 å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ k çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚ 

 è¿›é˜¶ï¼š 

 
 ä½ å¯ä»¥è®¾è®¡ä¸€ä¸ªåªä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´çš„ç®—æ³•æ¥è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ 
 ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚ 
 

 ç¤ºä¾‹ 1ï¼š 

 ```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
è¾“å‡ºï¼š[2,1,4,3,5]
 ```

 ç¤ºä¾‹ 2ï¼š 

 ```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 3
è¾“å‡ºï¼š[3,2,1,4,5]
 ```

 ç¤ºä¾‹ 3ï¼š 

 ```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 1
è¾“å‡ºï¼š[1,2,3,4,5]
 ```

 ç¤ºä¾‹ 4ï¼š 

 ```
è¾“å…¥ï¼šhead = [1], k = 1
è¾“å‡ºï¼š[1]
 ```

 
 

 æç¤ºï¼š 

 ```
 åˆ—è¡¨ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨èŒƒå›´ sz å†… 
 1 <= sz <= 5000 
 0 <= Node.val <= 1000 
 1 <= k <= sz 
 ```
 Related Topics é“¾è¡¨ 
 ğŸ‘ 936 ğŸ‘ 0

## é¢˜ç›®éš¾åº¦
> â˜…â˜…â˜…
## æ ¸å¿ƒçŸ¥è¯†
é“¾è¡¨åè½¬
## è§£é¢˜æ€è·¯

é¦–å…ˆæƒ³åˆ°çš„æ˜¯ç”¨ä¸´æ—¶æ•°ç»„æ–¹æ³•ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(k)ï¼Œè¦æ¯”O(n)å°ã€‚è¿™ç§æ–¹å¼ä¹Ÿæ˜¯æ¯”è¾ƒå¥½å†™çš„ï¼š

```java
public ListNode reverseKGroup(ListNode head, int k) {
    if (k == 1) {
        return head;
    }

    ListNode headNode = new ListNode();
    ListNode tailNode = headNode;

    ListNode[] cache = new ListNode[k];

    while (head != null) {
        int count = 0;
        // å°†kä¸ªèŠ‚ç‚¹ç¼“å­˜èµ·æ¥
        while (count < k && head != null) {
            cache[count] = head;
            head = head.next;
            count++;
        }

        if (count == k) {
            // å¦‚æœç¼“å­˜é•¿åº¦è¾¾åˆ°kï¼Œåˆ™åè½¬ä¹‹
            while (count > 0) {
                tailNode.next = cache[count - 1];
                tailNode = tailNode.next;
                count--;
            }
        } else {
            // å¦‚æœé•¿åº¦æ²¡è¾¾åˆ°kï¼Œåˆ™ä¿æŒåŸæ¥é¡ºåº
            tailNode.next = cache[0];
            tailNode = cache[count-1];
        }
    }

    tailNode.next = null;

    return headNode.next;
}

```

å®˜æ–¹é¢˜è§£çš„ç©ºé—´å¤æ‚åº¦æ›´ä½ï¼Œä½†æ˜¯æ€è·¯ç›¸å¯¹ç»•ã€‚

ä¸‹è¾¹ç”¨goè¯­è¨€åšäº†ä¸€æ¬¡ï¼š

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    cache := make([]*ListNode, k)

    newHead := &ListNode{}
    newTail := newHead

    for head != nil {
        count := 0
        for i := 0; i < k && head != nil; i++ {
            cache[i] = head
            head = head.Next
            count++
        }

        if count == k {
            for count > 0 {
                newTail.Next = cache[count - 1]
                newTail = newTail.Next
                count--
            }
        } else {
            newTail.Next = cache[0]
            newTail = cache[count - 1]
        }
    }
    // å°¾èŠ‚ç‚¹éœ€è¦æ¸…ç©ºå¼•ç”¨ï¼Œä»¥å…å‡ºç°å¾ªç¯çš„æƒ…å†µ
    newTail.Next = nil
    return newHead.Next
}

```
ç©ºé—´å¤æ‚åº¦æ›´ä½çš„åšæ³•ï¼š

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    newHead := &ListNode{Next:head}
    // éœ€è¦è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ä»¥ä¾¿æ¥å›åè½¬åçš„Ké“¾è¡¨
    pre := newHead
    currentNode := head
    // éå†ç›´åˆ°å½“å‰æŒ‡é’ˆåˆ°è¾¾å°¾éƒ¨nil
    for currentNode != nil {
        // å°¾èŠ‚ç‚¹ä»å‰ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œå‘åå¯»æ‰¾kä¸ªèŠ‚ç‚¹
        tail := pre
        for i:=0; i < k ;i++ {
            tail = tail.Next
            // å½“å°¾èŠ‚ç‚¹å·²ç»åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œåˆ™å¯ä»¥ç›´æ¥è¿”å›äº†ï¼Œä¸ç”¨å†åè½¬
            if tail == nil {
                return newHead.Next
            }
        }
        // æ­¤æ—¶åº”å½“åè½¬ currentNodeåˆ°tailä¹‹é—´çš„èŠ‚ç‚¹
        // åè½¬ä¹‹å‰å…ˆè®°å½•Ké“¾è¡¨åçš„èŠ‚ç‚¹ï¼Œä»¥ä¾¿åæ–‡æ¥å›æ¥
        next := tail.Next
        // æ¸…ç©ºtailåçš„èŠ‚ç‚¹ï¼Œé¿å…å¾ªç¯ï¼Œå¹¶ä¸”é—®é¢˜é€€åŒ–ä¸ºæ™®é€šçš„åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›æ–°çš„å¤´ç»“ç‚¹
        tail.Next = nil
        // åè½¬åçš„Ké“¾è¡¨è¢«æ¥åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹çš„next
        pre.Next = reverse(currentNode)
        // æ­¤æ—¶çš„currentNodeæ˜¯åè½¬åçš„Ké“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆšå¥½æ¥å›ä¸Šæ–‡çš„next
        currentNode.Next = next
        // æ­¤å¤„æ›´æ–°preï¼Œå¹¶ä¸”ç§»åŠ¨currentNodeå‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        pre = currentNode
        currentNode = next
    }
    return newHead.Next

}

func reverse(head *ListNode) (*ListNode){
    // åˆå§‹åŒ–å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºnil
    var pre *ListNode = nil
    current := head
    for current != nil {
        // å…ˆè®°å½•ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        next := current.Next
        // å½“å‰èŠ‚ç‚¹çš„nextæ¥åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹
        current.Next = pre
        // ç§»åŠ¨preå’ŒcurrentæŒ‡é’ˆ
        pre = current
        current = next
    }

    return pre
}

```

## å…¶ä»–è¡¥å……
